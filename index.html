<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'PingFang SC', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .hud-panel {
            pointer-events: auto;
            background: rgba(10, 20, 15, 0.5);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: #FFD700;
            padding: 20px;
            border-radius: 12px;
            width: 280px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.1);
        }

        h1 { margin: 0 0 10px 0; font-size: 1.2rem; letter-spacing: 1px; color: #fff; text-shadow: 0 0 5px #FFD700; }
        ul { padding-left: 20px; margin: 10px 0; color: #ddd; font-size: 0.85rem; line-height: 1.6; }
        
        .status-badge {
            display: inline-block; padding: 5px 10px; border-radius: 15px;
            background: rgba(220, 20, 60, 0.8); color: #fff; font-size: 0.8rem; margin-top: 10px;
            border: 1px solid #ff9999;
        }

        /* æŒ‰é’®æ ·å¼å›å½’ */
        #upload-btn {
            background: linear-gradient(45deg, #DC143C, #8B0000);
            border: 1px solid #FFD700; color: #fff;
            padding: 8px 15px; cursor: pointer; border-radius: 20px;
            font-size: 0.9rem; margin-top: 15px; width: 100%;
            transition: 0.3s; pointer-events: auto;
            box-shadow: 0 4px 10px rgba(220, 20, 60, 0.3);
        }
        #upload-btn:hover { transform: scale(1.05); background: #FF4500; }

        /* å‡†æ˜Ÿ */
        #reticle {
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px;
            transform: translate(-50%, -50%);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.2s;
        }
        #reticle.locked { 
            border-color: #FFD700; border-width: 3px; 
            transform: translate(-50%, -50%) scale(0.7); 
            box-shadow: 0 0 15px #FFD700;
        }

        .input_video { display: none; }
        
        /* Loading */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; align-items: center; justify-content: center;
            color: #FFD700; font-size: 1.1rem; flex-direction: column;
            transition: opacity 0.8s;
        }
    </style>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>

    <div id="loading">
        <div>æ­£åœ¨å‡†å¤‡æƒŠå–œ...</div>
        <div style="font-size: 0.8rem; margin-top:10px; color: #666;">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¼€å¯é­”æ³•</div>
    </div>

    <video class="input_video"></video>
    <div id="canvas-container"></div>
    <div id="reticle"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <h1>Merry Christmas</h1>
            <ul>
                <li>ğŸ‘‹ <b>ç§»åŠ¨æ‰‹æŒ</b>: æ—‹è½¬è§†è§’ (ä»»ä½•çŠ¶æ€)</li>
                <li>âœŠ <b>æ¡æ‹³</b>: èšåˆåœ£è¯æ ‘</li>
                <li>ğŸ– <b>å¼ å¼€äº”æŒ‡</b>: çƒŸèŠ±æ•£å¼€</li>
                <li>ğŸ‘Œ <b>æåˆ</b>: æŠ“å–ç…§ç‰‡ (å¯¹å‡†ä¸­å¿ƒ)</li>
            </ul>
            <div id="status-text" class="status-badge">ç­‰å¾…æ‰‹åŠ¿...</div>
            
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
            <button id="upload-btn" onclick="document.getElementById('file-input').click()">â• æ·»åŠ æ›´å¤šç…§ç‰‡</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ==========================================
        // ğŸ‘‡ è¿™é‡Œå¡«ä½ å‡†å¤‡å¥½çš„ç…§ç‰‡ï¼ˆGitHubéƒ¨ç½²ç”¨ï¼‰
        // ==========================================
        const PRELOADED_PHOTOS = [
            './1.jpg',
            './2.jpg',
             './3.jpg',
             './4.jpg',
             './5.jpg',
             './6.jpg',
             './7.jpg',
             './8.jpg',
             './9.jpg',
             './10.jpg',
             './11.jpg',
            './12.jpg',
            './13.jpg',
            './14.jpg',
            './15.jpg',
            './16.jpg',
            './17.jpg',
            './18.jpg',
            './19.jpg',
            './20.jpg',
            './21.jpg',
             './22.jpg',
             './23.jpg',
             './24.jpg',
             './25.jpg',
             './26.jpg',
             './27.jpg',
             './28.jpg',
             './29.jpg',
             './30.jpg',
            './31.jpg',
            './32.jpg',
            './33.jpg',
            './34.jpg',
            './35.jpg',
            './36.jpg',
            './37.jpg',
            './38.jpg',
            // å¦‚æœæœ¬åœ°æµ‹è¯•æ²¡æœ‰æ–‡ä»¶ï¼Œä»£ç ä¼šè‡ªåŠ¨è·³è¿‡ï¼Œä¸å½±å“è¿è¡Œ
        ];

        // --- Config ---
        const CONFIG = {
            particleCount: 700,
            treeHeight: 40,
            treeRadius: 16,
            scatterRadius: 65,
            colors: [0x2F4F4F, 0x1a2a1a, 0xFFD700, 0xDC143C], 
            bloomThreshold: 0.15,
            bloomStrength: 1.6,
            bloomRadius: 0.5
        };

        const STATE = {
            CONVERGED: 'converged',
            DISPERSED: 'dispersed',
            ZOOMED: 'zoomed',
            current: 'converged'
        };

        let activePhotoMesh = null;
        let isHandPresent = false;
        let handPosition = { x: 0, y: 0 }; 

        // --- Scene Setup ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 8, 60);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85));

        // --- Lights ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.2));
        const pLight = new THREE.PointLight(0xFFD700, 2, 100);
        pLight.position.set(10, 20, 10);
        scene.add(pLight);
        scene.add(new THREE.PointLight(0xDC143C, 2, 80)); // Red light

        // --- Objects ---
        const mainGroup = new THREE.Group(); // ç”¨äºæ•´ä½“æ—‹è½¬
        const particlesGroup = new THREE.Group();
        const photosGroup = new THREE.Group();
        mainGroup.add(particlesGroup);
        mainGroup.add(photosGroup);
        scene.add(mainGroup);

        const allObjects = [];

        // --- Particles ---
        const geometries = [
            new THREE.SphereGeometry(0.5, 12, 12),
            new THREE.BoxGeometry(0.7, 0.7, 0.7),
            new THREE.IcosahedronGeometry(0.6, 0)
        ];
        const matGold = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.9, roughness: 0.1 });
        const matRed = new THREE.MeshStandardMaterial({ color: 0xDC143C, metalness: 0.6, roughness: 0.2, emissive: 0x550000 });
        const matGreen = new THREE.MeshStandardMaterial({ color: 0x2F4F4F, metalness: 0.2, roughness: 0.8 });

        function getTreePos(i, total) {
            const r = (i/total) * CONFIG.treeRadius;
            const y = (1 - i/total) * CONFIG.treeHeight - CONFIG.treeHeight/2;
            const angle = i * 0.5;
            return new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
        }

        function getScatterPos() {
            const v = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
            return v.multiplyScalar(20 + Math.random() * CONFIG.scatterRadius);
        }

        function initParticles() {
            for(let i=0; i<CONFIG.particleCount; i++){
                const mesh = new THREE.Mesh(
                    geometries[Math.floor(Math.random()*3)],
                    Math.random()>0.8 ? matGold : (Math.random()>0.7 ? matRed : matGreen)
                );
                const treePos = getTreePos(i, CONFIG.particleCount);
                const scatterPos = getScatterPos();
                mesh.position.copy(treePos);
                mesh.rotation.set(Math.random()*3, Math.random()*3, 0);
                
                particlesGroup.add(mesh);
                allObjects.push({ mesh, treePos, scatterPos, type: 'particle', originalScale: mesh.scale.clone() });
            }
        }
        initParticles();

        // --- Photos Logic (Preload + Upload) ---
        function addPhotoToScene(img) {
            const tex = new THREE.Texture(img);
            tex.needsUpdate = true;
            tex.colorSpace = THREE.SRGBColorSpace;
            const aspect = img.width / img.height;
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(5, 5/aspect),
                new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true, opacity: 0.95 })
            );

            // éšæœºæ‰¾ä¸ªä½ç½®æ’å…¥
            const treeIdx = Math.floor(Math.random() * CONFIG.particleCount);
            const treePos = getTreePos(treeIdx, CONFIG.particleCount).multiplyScalar(1.3); // æµ®åœ¨è¡¨é¢
            if(Math.random()>0.5) treePos.x *= -1;
            
            const scatterPos = getScatterPos();
            
            mesh.position.copy(STATE.current === STATE.CONVERGED ? treePos : scatterPos);
            mesh.lookAt(0,0,0);
            
            photosGroup.add(mesh);
            allObjects.push({ 
                mesh, treePos, scatterPos, type: 'photo', 
                originalScale: new THREE.Vector3(1,1,1) 
            });

            // å¦‚æœå½“å‰å·²ç»åˆå§‹åŒ–è¿‡ï¼Œç»™ä¸ªå…¥åœºåŠ¨ç”»
            if(allObjects.length > CONFIG.particleCount + 10) {
                 gsap.from(mesh.scale, {x:0, y:0, z:0, duration: 1, ease: "back.out"});
            }
        }

        // 1. åŠ è½½é¢„è®¾
        PRELOADED_PHOTOS.forEach(url => {
            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = url;
            img.onload = () => addPhotoToScene(img);
        });

        // 2. å¤„ç†ä¸Šä¼ 
        document.getElementById('file-input').addEventListener('change', (e) => {
            Array.from(e.target.files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.src = ev.target.result;
                    img.onload = () => {
                        addPhotoToScene(img);
                        // ä¸Šä¼ åè‡ªåŠ¨åˆ‡æ¢åˆ°æ ‘å½¢æ€çœ‹æ•ˆæœ
                        if(STATE.current === STATE.DISPERSED) transitionTo(STATE.CONVERGED);
                    };
                };
                reader.readAsDataURL(file);
            });
        });

        // --- Transitions ---
        function transitionTo(newState) {
            if (newState === STATE.current && newState !== STATE.ZOOMED) return;
            STATE.current = newState;
            
            const txt = document.getElementById('status-text');
            txt.innerText = newState === STATE.CONVERGED ? "çŠ¶æ€: åœ£è¯æ ‘" : (newState === STATE.DISPERSED ? "çŠ¶æ€: æ¼«å¤©æ˜Ÿå…‰" : "çŠ¶æ€: æŠ“å–å›å¿†");
            txt.style.background = newState === STATE.CONVERGED ? "rgba(220, 20, 60, 0.8)" : "#333";

            allObjects.forEach(obj => {
                if (obj === activePhotoMesh && newState === STATE.ZOOMED) return;
                
                const target = newState === STATE.CONVERGED ? obj.treePos : obj.scatterPos;
                gsap.to(obj.mesh.position, {
                    x: target.x, y: target.y, z: target.z,
                    duration: 1.5 + Math.random(),
                    ease: "power2.inOut"
                });
                
                // æ ‘å½¢æ€ç…§ç‰‡é¢å‘ä¸­å¿ƒ
                if(obj.type === 'photo' && newState === STATE.CONVERGED) {
                    const dummy = new THREE.Object3D();
                    dummy.position.copy(target);
                    dummy.lookAt(0,0,0);
                    gsap.to(obj.mesh.quaternion, {
                        x: dummy.quaternion.x, y: dummy.quaternion.y, z: dummy.quaternion.z, w: dummy.quaternion.w,
                        duration: 1.5
                    });
                } else {
                    gsap.to(obj.mesh.rotation, {x: Math.random()*6, y: Math.random()*6, duration: 2});
                }
                
                // æ¢å¤ç¼©æ”¾
                gsap.to(obj.mesh.scale, {
                    x: obj.originalScale.x, y: obj.originalScale.y, z: obj.originalScale.z, 
                    duration: 0.5 
                });
            });
        }

        function zoomPhoto(wrapper) {
            if (STATE.current === STATE.ZOOMED) return;
            STATE.current = STATE.ZOOMED;
            activePhotoMesh = wrapper;

            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const targetPos = camera.position.clone().add(camDir.multiplyScalar(10));

            gsap.to(wrapper.mesh.position, {
                x: targetPos.x, y: targetPos.y, z: targetPos.z,
                duration: 1, ease: "power2.out",
                onUpdate: () => wrapper.mesh.lookAt(camera.position)
            });
            gsap.to(wrapper.mesh.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 1 });
        }

        // --- MediaPipe & Controls ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        
        function onResults(results) {
            document.getElementById('loading').style.opacity = 0;
            setTimeout(()=>document.getElementById('loading').style.display='none', 800);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandPresent = true;
                const lm = results.multiHandLandmarks[0];
                
                // æ˜ å°„æ‰‹åŠ¿ä½ç½® -> æ—‹è½¬
                const x = lm[9].x; 
                const y = lm[9].y;
                gsap.to(handPosition, { x: (x - 0.5) * 2, y: (y - 0.5) * 2, duration: 0.5 });

                // ç®€å•çš„æ‰‹åŠ¿è¯†åˆ«
                const dist = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
                const pinch = dist(4, 8) < 0.05;
                const fist = dist(8, 0) < 0.25 && dist(12, 0) < 0.25 && dist(16, 0) < 0.25;
                const open = !fist && !pinch;

                if (pinch) {
                    document.getElementById('reticle').classList.add('locked');
                    checkRaycast();
                } else {
                    document.getElementById('reticle').classList.remove('locked');
                    if (fist && STATE.current !== STATE.CONVERGED) {
                        activePhotoMesh = null; transitionTo(STATE.CONVERGED);
                    } else if (open && STATE.current === STATE.CONVERGED) {
                        transitionTo(STATE.DISPERSED);
                    } else if (open && STATE.current === STATE.ZOOMED) {
                        activePhotoMesh = null; transitionTo(STATE.DISPERSED);
                    }
                }
            } else {
                isHandPresent = false;
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);
        
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 640, height: 480
        });
        cameraUtils.start();

        // Raycast
        const raycaster = new THREE.Raycaster();
        function checkRaycast() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const hits = raycaster.intersectObjects(allObjects.filter(o=>o.type==='photo').map(o=>o.mesh));
            if(hits.length>0) {
                const wrapper = allObjects.find(o=>o.mesh===hits[0].object);
                if(wrapper) zoomPhoto(wrapper);
            }
        }

        // --- Loop ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // æ ¸å¿ƒé€»è¾‘ä¿®æ”¹ï¼šåªè¦æ‰‹åœ¨ï¼Œå°±å…è®¸æ—‹è½¬ï¼ˆä¹‹å‰é™åˆ¶äº†çŠ¶æ€ï¼‰
            if (isHandPresent) {
                const targetRotY = -handPosition.x * 1.5; 
                const targetRotX = -handPosition.y * 0.8;
                // å¹³æ»‘æ’å€¼
                mainGroup.rotation.y += (targetRotY - mainGroup.rotation.y) * 0.05;
                mainGroup.rotation.x += (targetRotX - mainGroup.rotation.x) * 0.05;
            } else {
                // æ²¡æ‰‹çš„æ—¶å€™è‡ªåŠ¨å½’ä½/æ—‹è½¬
                mainGroup.rotation.x += (0 - mainGroup.rotation.x) * 0.05;
                if(STATE.current === STATE.CONVERGED) mainGroup.rotation.y += 0.003; 
            }

            composer.render();
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>


